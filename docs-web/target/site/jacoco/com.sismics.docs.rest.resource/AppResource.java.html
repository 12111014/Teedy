<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AppResource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Docs Web</a> &gt; <a href="index.source.html" class="el_package">com.sismics.docs.rest.resource</a> &gt; <span class="el_source">AppResource.java</span></div><h1>AppResource.java</h1><pre class="source lang-java linenums">package com.sismics.docs.rest.resource;

import com.google.common.base.Strings;
import com.sismics.docs.core.constant.ConfigType;
import com.sismics.docs.core.constant.Constants;
import com.sismics.docs.core.dao.ConfigDao;
import com.sismics.docs.core.dao.DocumentDao;
import com.sismics.docs.core.dao.FileDao;
import com.sismics.docs.core.dao.UserDao;
import com.sismics.docs.core.event.RebuildIndexAsyncEvent;
import com.sismics.docs.core.model.context.AppContext;
import com.sismics.docs.core.model.jpa.Config;
import com.sismics.docs.core.model.jpa.File;
import com.sismics.docs.core.service.InboxService;
import com.sismics.docs.core.util.ConfigUtil;
import com.sismics.docs.core.util.DirectoryUtil;
import com.sismics.docs.core.util.authentication.LdapAuthenticationHandler;
import com.sismics.docs.core.util.jpa.PaginatedList;
import com.sismics.docs.core.util.jpa.PaginatedLists;
import com.sismics.docs.rest.constant.BaseFunction;
import com.sismics.rest.exception.ClientException;
import com.sismics.rest.exception.ForbiddenClientException;
import com.sismics.rest.exception.ServerException;
import com.sismics.rest.util.ValidationUtil;
import com.sismics.util.JsonUtil;
import com.sismics.util.context.ThreadLocalContext;
import com.sismics.util.log4j.LogCriteria;
import com.sismics.util.log4j.LogEntry;
import com.sismics.util.log4j.MemoryAppender;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Appender;
import org.apache.log4j.Level;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;
import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.ws.rs.*;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.text.MessageFormat;
import java.util.*;

/**
 * General app REST resource.
 * 
 * @author jtremeaux
 */
@Path(&quot;/app&quot;)
<span class="fc" id="L55">public class AppResource extends BaseResource {</span>
    /**
     * Logger.
     */
<span class="fc" id="L59">    private static final Logger log = LoggerFactory.getLogger(AppResource.class);</span>
    
    /**
     * Returns informations about the application.
     *
     * @api {get} /app Get application informations
     * @apiName GetApp
     * @apiGroup App
     * @apiSuccess {String} current_version API current version
     * @apiSuccess {String} min_version API minimum version
     * @apiSuccess {Boolean} guest_login True if guest login is enabled
     * @apiSuccess {String} default_language Default platform language
     * @apiSuccess {Number} queued_tasks Number of queued tasks waiting to be processed
     * @apiSuccess {String} total_memory Allocated JVM memory (in bytes)
     * @apiSuccess {String} free_memory Free JVM memory (in bytes)
     * @apiSuccess {String} document_count Number of documents
     * @apiSuccess {String} active_user_count Number of active users
     * @apiSuccess {String} global_storage_current Global storage currently used (in bytes)
     * @apiSuccess {String} global_storage_quota Maximum global storage (in bytes)
     * @apiPermission none
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @GET
    public Response info() {
<span class="fc" id="L85">        ResourceBundle configBundle = ConfigUtil.getConfigBundle();</span>
<span class="fc" id="L86">        String currentVersion = configBundle.getString(&quot;api.current_version&quot;);</span>
<span class="fc" id="L87">        String minVersion = configBundle.getString(&quot;api.min_version&quot;);</span>
<span class="fc" id="L88">        Boolean guestLogin = ConfigUtil.getConfigBooleanValue(ConfigType.GUEST_LOGIN);</span>
<span class="fc" id="L89">        String defaultLanguage = ConfigUtil.getConfigStringValue(ConfigType.DEFAULT_LANGUAGE);</span>
<span class="fc" id="L90">        UserDao userDao = new UserDao();</span>
<span class="fc" id="L91">        DocumentDao documentDao = new DocumentDao();</span>
<span class="fc" id="L92">        String globalQuotaStr = System.getenv(Constants.GLOBAL_QUOTA_ENV);</span>
<span class="fc" id="L93">        long globalQuota = 0;</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(globalQuotaStr)) {</span>
<span class="nc" id="L95">            globalQuota = Long.valueOf(globalQuotaStr);</span>
        }

<span class="fc" id="L98">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="fc" id="L99">                .add(&quot;current_version&quot;, currentVersion.replace(&quot;-SNAPSHOT&quot;, &quot;&quot;))</span>
<span class="fc" id="L100">                .add(&quot;min_version&quot;, minVersion)</span>
<span class="fc" id="L101">                .add(&quot;guest_login&quot;, guestLogin)</span>
<span class="fc" id="L102">                .add(&quot;default_language&quot;, defaultLanguage)</span>
<span class="fc" id="L103">                .add(&quot;queued_tasks&quot;, AppContext.getInstance().getQueuedTaskCount())</span>
<span class="fc" id="L104">                .add(&quot;total_memory&quot;, Runtime.getRuntime().totalMemory())</span>
<span class="fc" id="L105">                .add(&quot;free_memory&quot;, Runtime.getRuntime().freeMemory())</span>
<span class="fc" id="L106">                .add(&quot;document_count&quot;, documentDao.getDocumentCount())</span>
<span class="fc" id="L107">                .add(&quot;active_user_count&quot;, userDao.getActiveUserCount())</span>
<span class="fc" id="L108">                .add(&quot;global_storage_current&quot;, userDao.getGlobalStorageCurrent());</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (globalQuota &gt; 0) {</span>
<span class="nc" id="L110">            response.add(&quot;global_storage_quota&quot;, globalQuota);</span>
        }

<span class="fc" id="L113">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Enable/disable guest login.
     *
     * @api {post} /app/guest_login Enable/disable guest login
     * @apiName PostAppGuestLogin
     * @apiGroup App
     * @apiParam {Boolean} enabled If true, enable guest login
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @param enabled If true, enable guest login
     * @return Response
     */
    @POST
    @Path(&quot;guest_login&quot;)
    public Response guestLogin(@FormParam(&quot;enabled&quot;) Boolean enabled) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L134">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L136">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="fc" id="L138">        ConfigDao configDao = new ConfigDao();</span>
<span class="fc" id="L139">        configDao.update(ConfigType.GUEST_LOGIN, enabled.toString());</span>

<span class="fc" id="L141">        return Response.ok().build();</span>
    }

    /**
     * General application configuration.
     *
     * @api {post} /app/config General application configuration
     * @apiName PostAppConfig
     * @apiGroup App
     * @apiParam {String} default_language Default language
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @param defaultLanguage Default language
     * @return Response
     */
    @POST
    @Path(&quot;config&quot;)
    public Response config(@FormParam(&quot;default_language&quot;) String defaultLanguage) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L162">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L164">        checkBaseFunction(BaseFunction.ADMIN);</span>
<span class="fc" id="L165">        ValidationUtil.validateRequired(defaultLanguage, &quot;default_language&quot;);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (!Constants.SUPPORTED_LANGUAGES.contains(defaultLanguage)) {</span>
<span class="nc" id="L167">            throw new ClientException(&quot;ValidationError&quot;, MessageFormat.format(&quot;{0} is not a supported language&quot;, defaultLanguage));</span>
        }

<span class="fc" id="L170">        ConfigDao configDao = new ConfigDao();</span>
<span class="fc" id="L171">        configDao.update(ConfigType.DEFAULT_LANGUAGE, defaultLanguage);</span>

<span class="fc" id="L173">        return Response.ok().build();</span>
    }

    /**
     * Get the SMTP server configuration.
     *
     * @api {get} /app/config_smtp Get the SMTP server configuration
     * @apiName GetAppConfigSmtp
     * @apiGroup App
     * @apiSuccess {String} hostname SMTP hostname
     * @apiSuccess {String} port SMTP port
     * @apiSuccess {String} username SMTP username
     * @apiSuccess {String} password SMTP password
     * @apiSuccess {String} from From address
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @GET
    @Path(&quot;config_smtp&quot;)
    public Response getConfigSmtp() {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L197">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L199">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="fc" id="L201">        ConfigDao configDao = new ConfigDao();</span>
<span class="fc" id="L202">        Config hostnameConfig = configDao.getById(ConfigType.SMTP_HOSTNAME);</span>
<span class="fc" id="L203">        Config portConfig = configDao.getById(ConfigType.SMTP_PORT);</span>
<span class="fc" id="L204">        Config usernameConfig = configDao.getById(ConfigType.SMTP_USERNAME);</span>
<span class="fc" id="L205">        Config passwordConfig = configDao.getById(ConfigType.SMTP_PASSWORD);</span>
<span class="fc" id="L206">        Config fromConfig = configDao.getById(ConfigType.SMTP_FROM);</span>
<span class="fc" id="L207">        JsonObjectBuilder response = Json.createObjectBuilder();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(System.getenv(Constants.SMTP_HOSTNAME_ENV))) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (hostnameConfig == null) {</span>
<span class="fc" id="L210">                response.addNull(&quot;hostname&quot;);</span>
            } else {
<span class="fc" id="L212">                response.add(&quot;hostname&quot;, hostnameConfig.getValue());</span>
            }
        }
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(System.getenv(Constants.SMTP_PORT_ENV))) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (portConfig == null) {</span>
<span class="fc" id="L217">                response.addNull(&quot;port&quot;);</span>
            } else {
<span class="fc" id="L219">                response.add(&quot;port&quot;, Integer.valueOf(portConfig.getValue()));</span>
            }
        }
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(System.getenv(Constants.SMTP_USERNAME_ENV))) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (usernameConfig == null) {</span>
<span class="fc" id="L224">                response.addNull(&quot;username&quot;);</span>
            } else {
<span class="fc" id="L226">                response.add(&quot;username&quot;, usernameConfig.getValue());</span>
            }
        }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(System.getenv(Constants.SMTP_PASSWORD_ENV))) {</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (passwordConfig == null) {</span>
<span class="fc" id="L231">                response.addNull(&quot;password&quot;);</span>
            } else {
<span class="nc" id="L233">                response.add(&quot;password&quot;, passwordConfig.getValue());</span>
            }
        }
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (fromConfig == null) {</span>
<span class="fc" id="L237">            response.addNull(&quot;from&quot;);</span>
        } else {
<span class="fc" id="L239">            response.add(&quot;from&quot;, fromConfig.getValue());</span>
        }

<span class="fc" id="L242">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Configure the SMTP server.
     *
     * @api {post} /app/config_smtp Configure the SMTP server
     * @apiName PostAppConfigSmtp
     * @apiGroup App
     * @apiParam {String} hostname SMTP hostname
     * @apiParam {Integer} port SMTP port
     * @apiParam {String} username SMTP username
     * @apiParam {String} password SMTP password
     * @apiParam {String} from From address
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @param hostname SMTP hostname
     * @param portStr SMTP port
     * @param username SMTP username
     * @param password SMTP password
     * @param from From address
     * @return Response
     */
    @POST
    @Path(&quot;config_smtp&quot;)
    public Response configSmtp(@FormParam(&quot;hostname&quot;) String hostname,
                               @FormParam(&quot;port&quot;) String portStr,
                               @FormParam(&quot;username&quot;) String username,
                               @FormParam(&quot;password&quot;) String password,
                               @FormParam(&quot;from&quot;) String from) {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L276">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L278">        checkBaseFunction(BaseFunction.ADMIN);</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(portStr)) {</span>
<span class="fc" id="L280">            ValidationUtil.validateInteger(portStr, &quot;port&quot;);</span>
        }

        // Just update the changed configuration
<span class="fc" id="L284">        ConfigDao configDao = new ConfigDao();</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(hostname)) {</span>
<span class="fc" id="L286">            configDao.update(ConfigType.SMTP_HOSTNAME, hostname);</span>
        }
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(portStr)) {</span>
<span class="fc" id="L289">            configDao.update(ConfigType.SMTP_PORT, portStr);</span>
        }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(username)) {</span>
<span class="fc" id="L292">            configDao.update(ConfigType.SMTP_USERNAME, username);</span>
        }
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(password)) {</span>
<span class="nc" id="L295">            configDao.update(ConfigType.SMTP_PASSWORD, password);</span>
        }
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(from)) {</span>
<span class="fc" id="L298">            configDao.update(ConfigType.SMTP_FROM, from);</span>
        }

<span class="fc" id="L301">        return Response.ok().build();</span>
    }

    /**
     * Get the inbox configuration.
     *
     * @api {get} /app/config_inbox Get the inbox scanning configuration
     * @apiName GetAppConfigInbox
     * @apiGroup App
     * @apiSuccess {Boolean} enabled True if the inbox scanning is enabled
     * @apiSuccess {String} hostname IMAP hostname
     * @apiSuccess {String} port IMAP port
     * @apiSuccess {String} username IMAP username
     * @apiSuccess {String} password IMAP password
     * @apiSuccess {String} folder IMAP folder
     * @apiSuccess {String} tag Tag for created documents
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @GET
    @Path(&quot;config_inbox&quot;)
    public Response getConfigInbox() {
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L327">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L329">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="fc" id="L331">        ConfigDao configDao = new ConfigDao();</span>
<span class="fc" id="L332">        Boolean enabled = ConfigUtil.getConfigBooleanValue(ConfigType.INBOX_ENABLED);</span>
<span class="fc" id="L333">        Boolean autoTags = ConfigUtil.getConfigBooleanValue(ConfigType.INBOX_AUTOMATIC_TAGS);</span>
<span class="fc" id="L334">        Boolean deleteImported = ConfigUtil.getConfigBooleanValue(ConfigType.INBOX_DELETE_IMPORTED);</span>
<span class="fc" id="L335">        Config hostnameConfig = configDao.getById(ConfigType.INBOX_HOSTNAME);</span>
<span class="fc" id="L336">        Config portConfig = configDao.getById(ConfigType.INBOX_PORT);</span>
<span class="fc" id="L337">        Config usernameConfig = configDao.getById(ConfigType.INBOX_USERNAME);</span>
<span class="fc" id="L338">        Config passwordConfig = configDao.getById(ConfigType.INBOX_PASSWORD);</span>
<span class="fc" id="L339">        Config folderConfig = configDao.getById(ConfigType.INBOX_FOLDER);</span>
<span class="fc" id="L340">        Config tagConfig = configDao.getById(ConfigType.INBOX_TAG);</span>
<span class="fc" id="L341">        JsonObjectBuilder response = Json.createObjectBuilder();</span>

<span class="fc" id="L343">        response.add(&quot;enabled&quot;, enabled);</span>
<span class="fc" id="L344">        response.add(&quot;autoTagsEnabled&quot;, autoTags);</span>
<span class="fc" id="L345">        response.add(&quot;deleteImported&quot;, deleteImported);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (hostnameConfig == null) {</span>
<span class="nc" id="L347">            response.addNull(&quot;hostname&quot;);</span>
        } else {
<span class="fc" id="L349">            response.add(&quot;hostname&quot;, hostnameConfig.getValue());</span>
        }
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (portConfig == null) {</span>
<span class="nc" id="L352">            response.addNull(&quot;port&quot;);</span>
        } else {
<span class="fc" id="L354">            response.add(&quot;port&quot;, Integer.valueOf(portConfig.getValue()));</span>
        }
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (usernameConfig == null) {</span>
<span class="nc" id="L357">            response.addNull(&quot;username&quot;);</span>
        } else {
<span class="fc" id="L359">            response.add(&quot;username&quot;, usernameConfig.getValue());</span>
        }
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (passwordConfig == null) {</span>
<span class="nc" id="L362">            response.addNull(&quot;password&quot;);</span>
        } else {
<span class="fc" id="L364">            response.add(&quot;password&quot;, passwordConfig.getValue());</span>
        }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (folderConfig == null) {</span>
<span class="nc" id="L367">            response.addNull(&quot;folder&quot;);</span>
        } else {
<span class="fc" id="L369">            response.add(&quot;folder&quot;, folderConfig.getValue());</span>
        }
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (tagConfig == null) {</span>
<span class="nc" id="L372">            response.addNull(&quot;tag&quot;);</span>
        } else {
<span class="fc" id="L374">            response.add(&quot;tag&quot;, tagConfig.getValue());</span>
        }

        // Informations about the last synchronization
<span class="fc" id="L378">        InboxService inboxService = AppContext.getInstance().getInboxService();</span>
<span class="fc" id="L379">        JsonObjectBuilder lastSync = Json.createObjectBuilder();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (inboxService.getLastSyncDate() == null) {</span>
<span class="fc" id="L381">            lastSync.addNull(&quot;date&quot;);</span>
        } else {
<span class="fc" id="L383">            lastSync.add(&quot;date&quot;, inboxService.getLastSyncDate().getTime());</span>
        }
<span class="fc" id="L385">        lastSync.add(&quot;error&quot;, JsonUtil.nullable(inboxService.getLastSyncError()));</span>
<span class="fc" id="L386">        lastSync.add(&quot;count&quot;, inboxService.getLastSyncMessageCount());</span>
<span class="fc" id="L387">        response.add(&quot;last_sync&quot;, lastSync);</span>

<span class="fc" id="L389">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Configure the inbox.
     *
     * @api {post} /app/config_inbox Configure the inbox scanning
     * @apiName PostAppConfigInbox
     * @apiGroup App
     * @apiParam {Boolean} enabled True if the inbox scanning is enabled
     * @apiParam {Boolean} autoTagsEnabled If true automatically add tags to document (prefixed by #)
     * @apiParam {Boolean} deleteImported If true delete message from mailbox after import
     * @apiParam {String} hostname IMAP hostname
     * @apiParam {Integer} port IMAP port
     * @apiParam {String} username IMAP username
     * @apiParam {String} password IMAP password
     * @apiParam {String} folder IMAP folder
     * @apiParam {String} tag Tag for created documents
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @param enabled True if the inbox scanning is enabled
     * @param hostname IMAP hostname
     * @param portStr IMAP port
     * @param username IMAP username
     * @param password IMAP password
     * @param folder IMAP folder
     * @param tag Tag for created documents
     * @return Response
     */
    @POST
    @Path(&quot;config_inbox&quot;)
    public Response configInbox(@FormParam(&quot;enabled&quot;) Boolean enabled,
                                @FormParam(&quot;autoTagsEnabled&quot;) Boolean autoTagsEnabled,
                                @FormParam(&quot;deleteImported&quot;) Boolean deleteImported,
                                @FormParam(&quot;hostname&quot;) String hostname,
                                @FormParam(&quot;port&quot;) String portStr,
                                @FormParam(&quot;username&quot;) String username,
                                @FormParam(&quot;password&quot;) String password,
                                @FormParam(&quot;folder&quot;) String folder,
                                @FormParam(&quot;tag&quot;) String tag) {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L433">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L435">        checkBaseFunction(BaseFunction.ADMIN);</span>
<span class="fc" id="L436">        ValidationUtil.validateRequired(enabled, &quot;enabled&quot;);</span>
<span class="fc" id="L437">        ValidationUtil.validateRequired(autoTagsEnabled, &quot;autoTagsEnabled&quot;);</span>
<span class="fc" id="L438">        ValidationUtil.validateRequired(deleteImported, &quot;deleteImported&quot;);</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(portStr)) {</span>
<span class="fc" id="L440">            ValidationUtil.validateInteger(portStr, &quot;port&quot;);</span>
        }

        // Just update the changed configuration
<span class="fc" id="L444">        ConfigDao configDao = new ConfigDao();</span>
<span class="fc" id="L445">        configDao.update(ConfigType.INBOX_ENABLED, enabled.toString());</span>
<span class="fc" id="L446">        configDao.update(ConfigType.INBOX_AUTOMATIC_TAGS, autoTagsEnabled.toString());</span>
<span class="fc" id="L447">        configDao.update(ConfigType.INBOX_DELETE_IMPORTED, deleteImported.toString());</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(hostname)) {</span>
<span class="fc" id="L449">            configDao.update(ConfigType.INBOX_HOSTNAME, hostname);</span>
        }
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(portStr)) {</span>
<span class="fc" id="L452">            configDao.update(ConfigType.INBOX_PORT, portStr);</span>
        }
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(username)) {</span>
<span class="fc" id="L455">            configDao.update(ConfigType.INBOX_USERNAME, username);</span>
        }
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(password)) {</span>
<span class="fc" id="L458">            configDao.update(ConfigType.INBOX_PASSWORD, password);</span>
        }
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(folder)) {</span>
<span class="fc" id="L461">            configDao.update(ConfigType.INBOX_FOLDER, folder);</span>
        }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (!Strings.isNullOrEmpty(tag)) {</span>
<span class="fc" id="L464">            configDao.update(ConfigType.INBOX_TAG, tag);</span>
        }

<span class="fc" id="L467">        return Response.ok().build();</span>
    }

    /**
     * Test the inbox.
     *
     * @api {post} /app/test_inbox Test the inbox scanning
     * @apiName PostAppTestInbox
     * @apiGroup App
     * @apiSuccess {Number} Number of unread emails in the inbox
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @POST
    @Path(&quot;test_inbox&quot;)
    public Response testInbox() {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L487">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L489">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="fc" id="L491">        return Response.ok().entity(Json.createObjectBuilder()</span>
<span class="fc" id="L492">                .add(&quot;count&quot;, AppContext.getInstance().getInboxService().testInbox())</span>
<span class="fc" id="L493">                .build()).build();</span>
    }

    /**
     * Retrieve the application logs.
     *
     * @api {get} /app/log Get application logs
     * @apiName GetAppLog
     * @apiGroup App
     * @apiParam {String=&quot;FATAL&quot;,&quot;ERROR&quot;,&quot;WARN&quot;,&quot;INFO&quot;,&quot;DEBUG&quot;} level Minimum log level
     * @apiParam {String} tag Filter on this logger tag
     * @apiParam {String} message Filter on this message
     * @apiParam {Number} limit Total number of logs to return
     * @apiParam {Number} offset Start at this index
     * @apiSuccess {String} total Total number of logs
     * @apiSuccess {Object[]} logs List of logs
     * @apiSuccess {String} logs.date Date
     * @apiSuccess {String} logs.level Level
     * @apiSuccess {String} logs.tag Tag
     * @apiSuccess {String} logs.message Message
     * @apiError (client) ForbiddenError Access denied
     * @apiError (server) ServerError MEMORY appender not configured
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @param minLevel Filter on logging level
     * @param tag Filter on logger name / tag
     * @param message Filter on message
     * @param limit Page limit
     * @param offset Page offset
     * @return Response
     */
    @GET
    @Path(&quot;log&quot;)
    public Response log(
            @QueryParam(&quot;level&quot;) String minLevel,
            @QueryParam(&quot;tag&quot;) String tag,
            @QueryParam(&quot;message&quot;) String message,
            @QueryParam(&quot;limit&quot;) Integer limit,
            @QueryParam(&quot;offset&quot;) Integer offset) {
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L534">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L536">        checkBaseFunction(BaseFunction.ADMIN);</span>

        // Get the memory appender
<span class="fc" id="L539">        org.apache.log4j.Logger logger = org.apache.log4j.Logger.getRootLogger();</span>
<span class="fc" id="L540">        Appender appender = logger.getAppender(&quot;MEMORY&quot;);</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (!(appender instanceof MemoryAppender)) {</span>
<span class="nc" id="L542">            throw new ServerException(&quot;ServerError&quot;, &quot;MEMORY appender not configured&quot;);</span>
        }
<span class="fc" id="L544">        MemoryAppender memoryAppender = (MemoryAppender) appender;</span>
        
        // Find the logs
<span class="fc" id="L547">        LogCriteria logCriteria = new LogCriteria()</span>
<span class="fc" id="L548">                .setMinLevel(Level.toLevel(StringUtils.stripToNull(minLevel)))</span>
<span class="fc" id="L549">                .setTag(StringUtils.stripToNull(tag))</span>
<span class="fc" id="L550">                .setMessage(StringUtils.stripToNull(message));</span>
        
<span class="fc" id="L552">        PaginatedList&lt;LogEntry&gt; paginatedList = PaginatedLists.create(limit, offset);</span>
<span class="fc" id="L553">        memoryAppender.find(logCriteria, paginatedList);</span>
<span class="fc" id="L554">        JsonArrayBuilder logs = Json.createArrayBuilder();</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        for (LogEntry logEntry : paginatedList.getResultList()) {</span>
<span class="fc" id="L556">            logs.add(Json.createObjectBuilder()</span>
<span class="fc" id="L557">                    .add(&quot;date&quot;, logEntry.getTimestamp())</span>
<span class="fc" id="L558">                    .add(&quot;level&quot;, logEntry.getLevel().toString())</span>
<span class="fc" id="L559">                    .add(&quot;tag&quot;, logEntry.getTag())</span>
<span class="fc" id="L560">                    .add(&quot;message&quot;, logEntry.getMessage()));</span>
<span class="fc" id="L561">        }</span>
        
<span class="fc" id="L563">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="fc" id="L564">                .add(&quot;total&quot;, paginatedList.getResultCount())</span>
<span class="fc" id="L565">                .add(&quot;logs&quot;, logs);</span>
        
<span class="fc" id="L567">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Destroy and rebuild the search index.
     *
     * @api {post} /app/batch/reindex Rebuild the search index
     * @apiName PostAppBatchReindex
     * @apiGroup App
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (server) IndexingError Error rebuilding the index
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @POST
    @Path(&quot;batch/reindex&quot;)
    public Response batchReindex() {
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L588">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L590">        checkBaseFunction(BaseFunction.ADMIN);</span>
        
<span class="fc" id="L592">        RebuildIndexAsyncEvent rebuildIndexAsyncEvent = new RebuildIndexAsyncEvent();</span>
<span class="fc" id="L593">        ThreadLocalContext.get().addAsyncEvent(rebuildIndexAsyncEvent);</span>

        // Always return OK
<span class="fc" id="L596">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="fc" id="L597">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="fc" id="L598">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Clean storage.
     *
     * @api {post} /app/batch/clean_storage Clean the file and DB storage
     * @apiName PostAppBatchCleanStorage
     * @apiGroup App
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (server) FileError Error deleting orphan files
     * @apiPermission admin
     * @apiVersion 1.5.0
     *
     * @return Response
     */
    @POST
    @Path(&quot;batch/clean_storage&quot;)
    public Response batchCleanStorage() {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L619">            throw new ForbiddenClientException();</span>
        }
<span class="fc" id="L621">        checkBaseFunction(BaseFunction.ADMIN);</span>
        
        // Get all files
<span class="fc" id="L624">        FileDao fileDao = new FileDao();</span>
<span class="fc" id="L625">        List&lt;File&gt; fileList = fileDao.findAll(0, Integer.MAX_VALUE);</span>
<span class="fc" id="L626">        Map&lt;String, File&gt; fileMap = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        for (File file : fileList) {</span>
<span class="nc" id="L628">            fileMap.put(file.getId(), file);</span>
<span class="nc" id="L629">        }</span>
<span class="fc" id="L630">        log.info(&quot;Checking {} files&quot;, fileMap.size());</span>
        
        // Check if each stored file is valid
<span class="fc" id="L633">        try (DirectoryStream&lt;java.nio.file.Path&gt; storedFileList = Files.newDirectoryStream(DirectoryUtil.getStorageDirectory())) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            for (java.nio.file.Path storedFile : storedFileList) {</span>
<span class="fc" id="L635">                String fileName = storedFile.getFileName().toString();</span>
<span class="fc" id="L636">                String[] fileNameArray = fileName.split(&quot;_&quot;);</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">                if (!fileMap.containsKey(fileNameArray[0])) {</span>
<span class="fc" id="L638">                    log.info(&quot;Deleting orphan files at this location: {}&quot;, storedFile);</span>
<span class="fc" id="L639">                    Files.delete(storedFile);</span>
                }
<span class="fc" id="L641">            }</span>
<span class="nc" id="L642">        } catch (IOException e) {</span>
<span class="nc" id="L643">            throw new ServerException(&quot;FileError&quot;, &quot;Error deleting orphan files&quot;, e);</span>
<span class="fc" id="L644">        }</span>
        
        // Hard delete orphan audit logs
<span class="fc" id="L647">        EntityManager em = ThreadLocalContext.get().getEntityManager();</span>
<span class="fc" id="L648">        StringBuilder sb = new StringBuilder(&quot;delete from T_AUDIT_LOG al where al.LOG_ID_C in (select al.LOG_ID_C from T_AUDIT_LOG al &quot;);</span>
<span class="fc" id="L649">        sb.append(&quot; left join T_DOCUMENT d on d.DOC_ID_C = al.LOG_IDENTITY_C and d.DOC_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L650">        sb.append(&quot; left join T_ACL a on a.ACL_ID_C = al.LOG_IDENTITY_C and a.ACL_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L651">        sb.append(&quot; left join T_COMMENT c on c.COM_ID_C = al.LOG_IDENTITY_C and c.COM_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L652">        sb.append(&quot; left join T_FILE f on f.FIL_ID_C = al.LOG_IDENTITY_C and f.FIL_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L653">        sb.append(&quot; left join T_TAG t on t.TAG_ID_C = al.LOG_IDENTITY_C and t.TAG_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L654">        sb.append(&quot; left join T_USER u on u.USE_ID_C = al.LOG_IDENTITY_C and u.USE_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L655">        sb.append(&quot; left join T_GROUP g on g.GRP_ID_C = al.LOG_IDENTITY_C and g.GRP_DELETEDATE_D is null &quot;);</span>
<span class="fc" id="L656">        sb.append(&quot; where d.DOC_ID_C is null and a.ACL_ID_C is null and c.COM_ID_C is null and f.FIL_ID_C is null and t.TAG_ID_C is null and u.USE_ID_C is null and g.GRP_ID_C is null)&quot;);</span>
<span class="fc" id="L657">        Query q = em.createNativeQuery(sb.toString());</span>
<span class="fc" id="L658">        log.info(&quot;Deleting {} orphan audit logs&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan ACLs
<span class="fc" id="L661">        sb = new StringBuilder(&quot;update T_ACL a set ACL_DELETEDATE_D = :dateNow where a.ACL_ID_C in (select a.ACL_ID_C from T_ACL a &quot;);</span>
<span class="fc" id="L662">        sb.append(&quot; left join T_SHARE s on s.SHA_ID_C = a.ACL_TARGETID_C &quot;);</span>
<span class="fc" id="L663">        sb.append(&quot; left join T_USER u on u.USE_ID_C = a.ACL_TARGETID_C &quot;);</span>
<span class="fc" id="L664">        sb.append(&quot; left join T_GROUP g on g.GRP_ID_C = a.ACL_TARGETID_C &quot;);</span>
<span class="fc" id="L665">        sb.append(&quot; left join T_DOCUMENT d on d.DOC_ID_C = a.ACL_SOURCEID_C &quot;);</span>
<span class="fc" id="L666">        sb.append(&quot; left join T_TAG t on t.TAG_ID_C = a.ACL_SOURCEID_C &quot;);</span>
<span class="fc" id="L667">        sb.append(&quot; where s.SHA_ID_C is null and u.USE_ID_C is null and g.GRP_ID_C is null or d.DOC_ID_C is null and t.TAG_ID_C is null)&quot;);</span>
<span class="fc" id="L668">        q = em.createNativeQuery(sb.toString());</span>
<span class="fc" id="L669">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L670">        log.info(&quot;Deleting {} orphan ACLs&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan comments
<span class="fc" id="L673">        q = em.createNativeQuery(&quot;update T_COMMENT c set c.COM_DELETEDATE_D = :dateNow where c.COM_ID_C in (select c.COM_ID_C from T_COMMENT c left join T_DOCUMENT d on d.DOC_ID_C = c.COM_IDDOC_C and d.DOC_DELETEDATE_D is null where d.DOC_ID_C is null)&quot;);</span>
<span class="fc" id="L674">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L675">        log.info(&quot;Deleting {} orphan comments&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan document tag links
<span class="fc" id="L678">        q = em.createNativeQuery(&quot;update T_DOCUMENT_TAG dt set dt.DOT_DELETEDATE_D = :dateNow where dt.DOT_ID_C in (select dt.DOT_ID_C from T_DOCUMENT_TAG dt left join T_DOCUMENT d on dt.DOT_IDDOCUMENT_C = d.DOC_ID_C and d.DOC_DELETEDATE_D is null left join T_TAG t on t.TAG_ID_C = dt.DOT_IDTAG_C and t.TAG_DELETEDATE_D is null where d.DOC_ID_C is null or t.TAG_ID_C is null)&quot;);</span>
<span class="fc" id="L679">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L680">        log.info(&quot;Deleting {} orphan document tag links&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan shares
<span class="fc" id="L683">        q = em.createNativeQuery(&quot;update T_SHARE s set s.SHA_DELETEDATE_D = :dateNow where s.SHA_ID_C in (select s.SHA_ID_C from T_SHARE s left join T_ACL a on a.ACL_TARGETID_C = s.SHA_ID_C and a.ACL_DELETEDATE_D is null where a.ACL_ID_C is null)&quot;);</span>
<span class="fc" id="L684">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L685">        log.info(&quot;Deleting {} orphan shares&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan tags
<span class="fc" id="L688">        q = em.createNativeQuery(&quot;update T_TAG t set t.TAG_DELETEDATE_D = :dateNow where t.TAG_ID_C in (select t.TAG_ID_C from T_TAG t left join T_USER u on u.USE_ID_C = t.TAG_IDUSER_C and u.USE_DELETEDATE_D is null where u.USE_ID_C is null)&quot;);</span>
<span class="fc" id="L689">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L690">        log.info(&quot;Deleting {} orphan tags&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan documents
<span class="fc" id="L693">        q = em.createNativeQuery(&quot;update T_DOCUMENT d set d.DOC_DELETEDATE_D = :dateNow where d.DOC_ID_C in (select d.DOC_ID_C from T_DOCUMENT d left join T_USER u on u.USE_ID_C = d.DOC_IDUSER_C and u.USE_DELETEDATE_D is null where u.USE_ID_C is null)&quot;);</span>
<span class="fc" id="L694">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L695">        log.info(&quot;Deleting {} orphan documents&quot;, q.executeUpdate());</span>
        
        // Soft delete orphan files
<span class="fc" id="L698">        q = em.createNativeQuery(&quot;update T_FILE f set f.FIL_DELETEDATE_D = :dateNow where f.FIL_ID_C in (select f.FIL_ID_C from T_FILE f left join T_USER u on u.USE_ID_C = f.FIL_IDUSER_C and u.USE_DELETEDATE_D is null where u.USE_ID_C is null)&quot;);</span>
<span class="fc" id="L699">        q.setParameter(&quot;dateNow&quot;, new Date());</span>
<span class="fc" id="L700">        log.info(&quot;Deleting {} orphan files&quot;, q.executeUpdate());</span>
        
        // Hard delete softly deleted data
<span class="fc" id="L703">        log.info(&quot;Deleting {} soft deleted document tag links&quot;, em.createQuery(&quot;delete DocumentTag dt where dt.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L704">        log.info(&quot;Deleting {} soft deleted ACLs&quot;, em.createQuery(&quot;delete Acl a where a.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L705">        log.info(&quot;Deleting {} soft deleted shares&quot;, em.createQuery(&quot;delete Share s where s.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L706">        log.info(&quot;Deleting {} soft deleted tags&quot;, em.createQuery(&quot;delete Tag t where t.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L707">        log.info(&quot;Deleting {} soft deleted comments&quot;, em.createQuery(&quot;delete Comment c where c.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L708">        log.info(&quot;Deleting {} soft deleted files&quot;, em.createQuery(&quot;delete File f where f.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L709">        log.info(&quot;Deleting {} soft deleted documents&quot;, em.createQuery(&quot;delete Document d where d.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L710">        log.info(&quot;Deleting {} soft deleted users&quot;, em.createQuery(&quot;delete User u where u.deleteDate is not null&quot;).executeUpdate());</span>
<span class="fc" id="L711">        log.info(&quot;Deleting {} soft deleted groups&quot;, em.createQuery(&quot;delete Group g where g.deleteDate is not null&quot;).executeUpdate());</span>
        
        // Always return OK
<span class="fc" id="L714">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="fc" id="L715">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="fc" id="L716">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Get the LDAP authentication configuration.
     *
     * @api {get} /app/config_ldap Get the LDAP authentication configuration
     * @apiName GetAppConfigLdap
     * @apiGroup App
     * @apiSuccess {Boolean} enabled LDAP authentication enabled
     * @apiSuccess {String} host LDAP server host
     * @apiSuccess {Integer} port LDAP server port
     * @apiSuccess {String} admin_dn Admin DN
     * @apiSuccess {String} admin_password Admin password
     * @apiSuccess {String} base_dn Base DN
     * @apiSuccess {String} filter LDAP filter
     * @apiSuccess {String} default_email LDAP default email
     * @apiSuccess {Integer} default_storage LDAP default storage
     * @apiError (client) ForbiddenError Access denied
     * @apiPermission admin
     * @apiVersion 1.9.0
     *
     * @return Response
     */
    @GET
    @Path(&quot;config_ldap&quot;)
    public Response getConfigLdap() {
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L744">            throw new ForbiddenClientException();</span>
        }
<span class="nc" id="L746">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="nc" id="L748">        ConfigDao configDao = new ConfigDao();</span>
<span class="nc" id="L749">        Config enabled = configDao.getById(ConfigType.LDAP_ENABLED);</span>

<span class="nc" id="L751">        JsonObjectBuilder response = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">        if (enabled != null &amp;&amp; Boolean.parseBoolean(enabled.getValue())) {</span>
            // LDAP enabled
<span class="nc" id="L754">            response.add(&quot;enabled&quot;, true)</span>
<span class="nc" id="L755">                    .add(&quot;host&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_HOST))</span>
<span class="nc" id="L756">                    .add(&quot;port&quot;, ConfigUtil.getConfigIntegerValue(ConfigType.LDAP_PORT))</span>
<span class="nc" id="L757">                    .add(&quot;admin_dn&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_ADMIN_DN))</span>
<span class="nc" id="L758">                    .add(&quot;admin_password&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_ADMIN_PASSWORD))</span>
<span class="nc" id="L759">                    .add(&quot;base_dn&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_BASE_DN))</span>
<span class="nc" id="L760">                    .add(&quot;filter&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_FILTER))</span>
<span class="nc" id="L761">                    .add(&quot;default_email&quot;, ConfigUtil.getConfigStringValue(ConfigType.LDAP_DEFAULT_EMAIL))</span>
<span class="nc" id="L762">                    .add(&quot;default_storage&quot;, ConfigUtil.getConfigLongValue(ConfigType.LDAP_DEFAULT_STORAGE));</span>
        } else {
            // LDAP disabled
<span class="nc" id="L765">            response.add(&quot;enabled&quot;, false);</span>
        }

<span class="nc" id="L768">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Configure the LDAP authentication.
     *
     * @api {post} /app/config_ldap Configure the LDAP authentication
     * @apiName PostAppConfigLdap
     * @apiGroup App
     * @apiParam {Boolean} enabled LDAP authentication enabled
     * @apiParam {String} host LDAP server host
     * @apiParam {Integer} port LDAP server port
     * @apiParam {String} admin_dn Admin DN
     * @apiParam {String} admin_password Admin password
     * @apiParam {String} base_dn Base DN
     * @apiParam {String} filter LDAP filter
     * @apiParam {String} default_email LDAP default email
     * @apiParam {Integer} default_storage LDAP default storage
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiPermission admin
     * @apiVersion 1.9.0
     *
     * @param enabled LDAP authentication enabled
     * @param host LDAP server host
     * @param portStr LDAP server port
     * @param adminDn Admin DN
     * @param adminPassword Admin password
     * @param baseDn Base DN
     * @param filter LDAP filter
     * @param defaultEmail LDAP default email
     * @param defaultStorageStr LDAP default storage
     * @return Response
     */
    @POST
    @Path(&quot;config_ldap&quot;)
    public Response configLdap(@FormParam(&quot;enabled&quot;) Boolean enabled,
                               @FormParam(&quot;host&quot;) String host,
                               @FormParam(&quot;port&quot;) String portStr,
                               @FormParam(&quot;admin_dn&quot;) String adminDn,
                               @FormParam(&quot;admin_password&quot;) String adminPassword,
                               @FormParam(&quot;base_dn&quot;) String baseDn,
                               @FormParam(&quot;filter&quot;) String filter,
                               @FormParam(&quot;default_email&quot;) String defaultEmail,
                               @FormParam(&quot;default_storage&quot;) String defaultStorageStr) {
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L814">            throw new ForbiddenClientException();</span>
        }
<span class="nc" id="L816">        checkBaseFunction(BaseFunction.ADMIN);</span>

<span class="nc" id="L818">        ConfigDao configDao = new ConfigDao();</span>

<span class="nc bnc" id="L820" title="All 4 branches missed.">        if (enabled != null &amp;&amp; enabled) {</span>
            // LDAP enabled, validate everything
<span class="nc" id="L822">            ValidationUtil.validateLength(host, &quot;host&quot;, 1, 250);</span>
<span class="nc" id="L823">            ValidationUtil.validateInteger(portStr, &quot;port&quot;);</span>
<span class="nc" id="L824">            ValidationUtil.validateLength(adminDn, &quot;admin_dn&quot;, 1, 250);</span>
<span class="nc" id="L825">            ValidationUtil.validateLength(adminPassword, &quot;admin_password&quot;, 1, 250);</span>
<span class="nc" id="L826">            ValidationUtil.validateLength(baseDn, &quot;base_dn&quot;, 1, 250);</span>
<span class="nc" id="L827">            ValidationUtil.validateLength(filter, &quot;filter&quot;, 1, 250);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (!filter.contains(&quot;USERNAME&quot;)) {</span>
<span class="nc" id="L829">                throw new ClientException(&quot;ValidationError&quot;, &quot;'filter' must contains 'USERNAME'&quot;);</span>
            }
<span class="nc" id="L831">            ValidationUtil.validateLength(defaultEmail, &quot;default_email&quot;, 1, 250);</span>
<span class="nc" id="L832">            ValidationUtil.validateLong(defaultStorageStr, &quot;default_storage&quot;);</span>
<span class="nc" id="L833">            configDao.update(ConfigType.LDAP_ENABLED, Boolean.TRUE.toString());</span>
<span class="nc" id="L834">            configDao.update(ConfigType.LDAP_HOST, host);</span>
<span class="nc" id="L835">            configDao.update(ConfigType.LDAP_PORT, portStr);</span>
<span class="nc" id="L836">            configDao.update(ConfigType.LDAP_ADMIN_DN, adminDn);</span>
<span class="nc" id="L837">            configDao.update(ConfigType.LDAP_ADMIN_PASSWORD, adminPassword);</span>
<span class="nc" id="L838">            configDao.update(ConfigType.LDAP_BASE_DN, baseDn);</span>
<span class="nc" id="L839">            configDao.update(ConfigType.LDAP_FILTER, filter);</span>
<span class="nc" id="L840">            configDao.update(ConfigType.LDAP_DEFAULT_EMAIL, defaultEmail);</span>
<span class="nc" id="L841">            configDao.update(ConfigType.LDAP_DEFAULT_STORAGE, defaultStorageStr);</span>
        } else {
            // LDAP disabled
<span class="nc" id="L844">            configDao.update(ConfigType.LDAP_ENABLED, Boolean.FALSE.toString());</span>
        }

        // Reset the LDAP pool to reconnect with the new configuration
<span class="nc" id="L848">        LdapAuthenticationHandler.reset();</span>

<span class="nc" id="L850">        return Response.ok().build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>