<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileResource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Docs Web</a> &gt; <a href="index.source.html" class="el_package">com.sismics.docs.rest.resource</a> &gt; <span class="el_source">FileResource.java</span></div><h1>FileResource.java</h1><pre class="source lang-java linenums">package com.sismics.docs.rest.resource;

import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.io.ByteStreams;
import com.sismics.docs.core.constant.PermType;
import com.sismics.docs.core.dao.AclDao;
import com.sismics.docs.core.dao.DocumentDao;
import com.sismics.docs.core.dao.FileDao;
import com.sismics.docs.core.dao.UserDao;
import com.sismics.docs.core.dao.dto.DocumentDto;
import com.sismics.docs.core.event.DocumentUpdatedAsyncEvent;
import com.sismics.docs.core.event.FileDeletedAsyncEvent;
import com.sismics.docs.core.event.FileUpdatedAsyncEvent;
import com.sismics.docs.core.model.context.AppContext;
import com.sismics.docs.core.model.jpa.File;
import com.sismics.docs.core.model.jpa.User;
import com.sismics.docs.core.util.DirectoryUtil;
import com.sismics.docs.core.util.EncryptionUtil;
import com.sismics.docs.core.util.FileUtil;
import com.sismics.rest.exception.ClientException;
import com.sismics.rest.exception.ForbiddenClientException;
import com.sismics.rest.exception.ServerException;
import com.sismics.rest.util.RestUtil;
import com.sismics.rest.util.ValidationUtil;
import com.sismics.util.HttpUtil;
import com.sismics.util.JsonUtil;
import com.sismics.util.context.ThreadLocalContext;
import com.sismics.util.mime.MimeType;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;
import org.glassfish.jersey.media.multipart.FormDataParam;

import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;
import javax.ws.rs.*;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.StreamingOutput;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.MessageFormat;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * File REST resources.
 * 
 * @author bgamard
 */
@Path(&quot;/file&quot;)
<span class="fc" id="L61">public class FileResource extends BaseResource {</span>
    /**
     * Add a file (with or without a document).
     *
     * @api {put} /file Add a file
     * @apiDescription A file can be added without associated document, and will go in a temporary storage waiting for one.
     * This resource accepts only multipart/form-data.
     * @apiName PutFile
     * @apiGroup File
     * @apiParam {String} id Document ID
     * @apiParam {String} previousFileId ID of the file to replace by this new version
     * @apiParam {String} file File data
     * @apiSuccess {String} status Status OK
     * @apiSuccess {String} id File ID
     * @apiSuccess {Number} size File size (in bytes)
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiError (client) NotFound Document not found
     * @apiError (server) StreamError Error reading the input file
     * @apiError (server) ErrorGuessMime Error guessing mime type
     * @apiError (client) QuotaReached Quota limit reached
     * @apiError (server) FileError Error adding a file
     * @apiPermission user
     * @apiVersion 1.5.0
     *
     * @param documentId Document ID
     * @param fileBodyPart File to add
     * @return Response
     */
    @PUT
    @Consumes(&quot;multipart/form-data&quot;)
    public Response add(
            @FormDataParam(&quot;id&quot;) String documentId,
            @FormDataParam(&quot;previousFileId&quot;) String previousFileId,
            @FormDataParam(&quot;file&quot;) FormDataBodyPart fileBodyPart) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L97">            throw new ForbiddenClientException();</span>
        }
        
        // Validate input data
<span class="fc" id="L101">        ValidationUtil.validateRequired(fileBodyPart, &quot;file&quot;);</span>

        // Get the document
<span class="fc" id="L104">        DocumentDto documentDto = null;</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (Strings.isNullOrEmpty(documentId)) {</span>
<span class="nc" id="L106">            documentId = null;</span>
        } else {
<span class="fc" id="L108">            DocumentDao documentDao = new DocumentDao();</span>
<span class="fc" id="L109">            documentDto = documentDao.getDocument(documentId, PermType.WRITE, getTargetIdList(null));</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if (documentDto == null) {</span>
<span class="nc" id="L111">                throw new NotFoundException();</span>
            }
        }
        
        // Keep unencrypted data temporary on disk
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        String name = fileBodyPart.getContentDisposition() != null ?</span>
<span class="pc" id="L117">                URLDecoder.decode(fileBodyPart.getContentDisposition().getFileName(), StandardCharsets.UTF_8) : null;</span>
        java.nio.file.Path unencryptedFile;
        long fileSize;
        try {
<span class="fc" id="L121">            unencryptedFile = AppContext.getInstance().getFileService().createTemporaryFile(name);</span>
<span class="fc" id="L122">            Files.copy(fileBodyPart.getValueAs(InputStream.class), unencryptedFile, StandardCopyOption.REPLACE_EXISTING);</span>
<span class="fc" id="L123">            fileSize = Files.size(unencryptedFile);</span>
<span class="nc" id="L124">        } catch (IOException e) {</span>
<span class="nc" id="L125">            throw new ServerException(&quot;StreamError&quot;, &quot;Error reading the input file&quot;, e);</span>
<span class="fc" id="L126">        }</span>

        try {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            String fileId = FileUtil.createFile(name, previousFileId, unencryptedFile, fileSize, documentDto == null ?</span>
<span class="pc" id="L130">                    null : documentDto.getLanguage(), principal.getId(), documentId);</span>

            // Always return OK
<span class="fc" id="L133">            JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="fc" id="L134">                    .add(&quot;status&quot;, &quot;ok&quot;)</span>
<span class="fc" id="L135">                    .add(&quot;id&quot;, fileId)</span>
<span class="fc" id="L136">                    .add(&quot;size&quot;, fileSize);</span>
<span class="fc" id="L137">            return Response.ok().entity(response.build()).build();</span>
<span class="nc" id="L138">        } catch (IOException e) {</span>
<span class="nc" id="L139">            throw new ClientException(e.getMessage(), e.getMessage(), e);</span>
<span class="nc" id="L140">        } catch (Exception e) {</span>
<span class="nc" id="L141">            throw new ServerException(&quot;FileError&quot;, &quot;Error adding a file&quot;, e);</span>
        }
    }
    
    /**
     * Attach a file to a document.
     *
     * @api {post} /file/:fileId/attach Attach a file to a document
     * @apiName PostFileAttach
     * @apiGroup File
     * @apiParam {String} fileId File ID
     * @apiParam {String} id Document ID
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiError (client) IllegalFile File not orphan
     * @apiError (server) AttachError Error attaching file to document
     * @apiPermission user
     * @apiVersion 1.5.0
     *
     * @param id File ID
     * @return Response
     */
    @POST
    @Path(&quot;{id: [a-z0-9\\-]+}/attach&quot;)
    public Response attach(
            @PathParam(&quot;id&quot;) String id,
            @FormParam(&quot;id&quot;) String documentId) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L170">            throw new ForbiddenClientException();</span>
        }

        // Validate input data
<span class="nc" id="L174">        ValidationUtil.validateRequired(documentId, &quot;documentId&quot;);</span>
        
        // Get the current user
<span class="nc" id="L177">        UserDao userDao = new UserDao();</span>
<span class="nc" id="L178">        User user = userDao.getById(principal.getId());</span>
        
        // Get the document and the file
<span class="nc" id="L181">        DocumentDao documentDao = new DocumentDao();</span>
<span class="nc" id="L182">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L183">        File file = fileDao.getFile(id, principal.getId());</span>
<span class="nc" id="L184">        DocumentDto documentDto = documentDao.getDocument(documentId, PermType.WRITE, getTargetIdList(null));</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (file == null || documentDto == null) {</span>
<span class="nc" id="L186">            throw new NotFoundException();</span>
        }
        
        // Check that the file is orphan
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (file.getDocumentId() != null) {</span>
<span class="nc" id="L191">            throw new ClientException(&quot;IllegalFile&quot;, MessageFormat.format(&quot;File not orphan: {0}&quot;, id));</span>
        }
        
        // Update the file
<span class="nc" id="L195">        file.setDocumentId(documentId);</span>
<span class="nc" id="L196">        file.setOrder(fileDao.getByDocumentId(principal.getId(), documentId).size());</span>
<span class="nc" id="L197">        fileDao.update(file);</span>
        
        // Raise a new file updated event and document updated event (it wasn't sent during file creation)
        try {
<span class="nc" id="L201">            java.nio.file.Path storedFile = DirectoryUtil.getStorageDirectory().resolve(id);</span>
<span class="nc" id="L202">            java.nio.file.Path unencryptedFile = EncryptionUtil.decryptFile(storedFile, user.getPrivateKey());</span>
<span class="nc" id="L203">            FileUtil.startProcessingFile(id);</span>
<span class="nc" id="L204">            FileUpdatedAsyncEvent fileUpdatedAsyncEvent = new FileUpdatedAsyncEvent();</span>
<span class="nc" id="L205">            fileUpdatedAsyncEvent.setUserId(principal.getId());</span>
<span class="nc" id="L206">            fileUpdatedAsyncEvent.setLanguage(documentDto.getLanguage());</span>
<span class="nc" id="L207">            fileUpdatedAsyncEvent.setFileId(file.getId());</span>
<span class="nc" id="L208">            fileUpdatedAsyncEvent.setUnencryptedFile(unencryptedFile);</span>
<span class="nc" id="L209">            ThreadLocalContext.get().addAsyncEvent(fileUpdatedAsyncEvent);</span>
            
<span class="nc" id="L211">            DocumentUpdatedAsyncEvent documentUpdatedAsyncEvent = new DocumentUpdatedAsyncEvent();</span>
<span class="nc" id="L212">            documentUpdatedAsyncEvent.setUserId(principal.getId());</span>
<span class="nc" id="L213">            documentUpdatedAsyncEvent.setDocumentId(documentId);</span>
<span class="nc" id="L214">            ThreadLocalContext.get().addAsyncEvent(documentUpdatedAsyncEvent);</span>
<span class="nc" id="L215">        } catch (Exception e) {</span>
<span class="nc" id="L216">            throw new ServerException(&quot;AttachError&quot;, &quot;Error attaching file to document&quot;, e);</span>
<span class="nc" id="L217">        }</span>

        // Always return OK
<span class="nc" id="L220">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L221">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="nc" id="L222">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Update a file.
     *
     * @api {post} /file/:id Update a file
     * @apiName PostFile
     * @apiGroup File
     * @apiParam {String} id File ID
     * @apiParam {String} name Name
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiPermission user
     * @apiVersion 1.6.0
     *
     * @param id File ID
     * @return Response
     */
    @POST
    @Path(&quot;{id: [a-z0-9\\-]+}&quot;)
    public Response update(@PathParam(&quot;id&quot;) String id,
                           @FormParam(&quot;name&quot;) String name) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L247">            throw new ForbiddenClientException();</span>
        }

        // Get the file
<span class="nc" id="L251">        File file = findFile(id, null);</span>

        // Validate input data
<span class="nc" id="L254">        name = ValidationUtil.validateLength(name, &quot;name&quot;, 1, 200, false);</span>

        // Update the file
<span class="nc" id="L257">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L258">        file.setName(name);</span>
<span class="nc" id="L259">        fileDao.update(file);</span>

        // Always return OK
<span class="nc" id="L262">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L263">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="nc" id="L264">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * Process a file manually.
     *
     * @api {post} /file/:id/process Process a file manually
     * @apiName PostFileProcess
     * @apiGroup File
     * @apiParam {String} id File ID
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiError (server) ProcessingError Processing error
     * @apiPermission user
     * @apiVersion 1.6.0
     *
     * @param id File ID
     * @return Response
     */
    @POST
    @Path(&quot;{id: [a-z0-9\\-]+}/process&quot;)
    public Response process(@PathParam(&quot;id&quot;) String id) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L288">            throw new ForbiddenClientException();</span>
        }

        // Get the document and the file
<span class="nc" id="L292">        DocumentDao documentDao = new DocumentDao();</span>
<span class="nc" id="L293">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L294">        File file = fileDao.getFile(id);</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">        if (file == null || file.getDocumentId() == null) {</span>
<span class="nc" id="L296">            throw new NotFoundException();</span>
        }
<span class="nc" id="L298">        DocumentDto documentDto = documentDao.getDocument(file.getDocumentId(), PermType.WRITE, getTargetIdList(null));</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (documentDto == null) {</span>
<span class="nc" id="L300">            throw new NotFoundException();</span>
        }

        // Get the creating user
<span class="nc" id="L304">        UserDao userDao = new UserDao();</span>
<span class="nc" id="L305">        User user = userDao.getById(file.getUserId());</span>

        // Start the processing asynchronously
        try {
<span class="nc" id="L309">            java.nio.file.Path storedFile = DirectoryUtil.getStorageDirectory().resolve(id);</span>
<span class="nc" id="L310">            java.nio.file.Path unencryptedFile = EncryptionUtil.decryptFile(storedFile, user.getPrivateKey());</span>
<span class="nc" id="L311">            FileUtil.startProcessingFile(id);</span>
<span class="nc" id="L312">            FileUpdatedAsyncEvent event = new FileUpdatedAsyncEvent();</span>
<span class="nc" id="L313">            event.setUserId(principal.getId());</span>
<span class="nc" id="L314">            event.setLanguage(documentDto.getLanguage());</span>
<span class="nc" id="L315">            event.setFileId(file.getId());</span>
<span class="nc" id="L316">            event.setUnencryptedFile(unencryptedFile);</span>
<span class="nc" id="L317">            ThreadLocalContext.get().addAsyncEvent(event);</span>
<span class="nc" id="L318">        } catch (Exception e) {</span>
<span class="nc" id="L319">            throw new ServerException(&quot;ProcessingError&quot;, &quot;Error processing this file&quot;, e);</span>
<span class="nc" id="L320">        }</span>

        // Always return OK
<span class="nc" id="L323">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L324">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="nc" id="L325">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Reorder files.
     *
     * @api {post} /file/:reorder Reorder files
     * @apiName PostFileReorder
     * @apiGroup File
     * @apiParam {String} id Document ID
     * @apiParam {String[]} order List of files ID
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) ValidationError Validation error
     * @apiError (client) NotFound Document not found
     * @apiPermission user
     * @apiVersion 1.5.0
     *
     * @param documentId Document ID
     * @param idList List of files ID in the new order
     * @return Response
     */
    @POST
    @Path(&quot;reorder&quot;)
    public Response reorder(
            @FormParam(&quot;id&quot;) String documentId,
            @FormParam(&quot;order&quot;) List&lt;String&gt; idList) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L353">            throw new ForbiddenClientException();</span>
        }
        
        // Validate input data
<span class="nc" id="L357">        ValidationUtil.validateRequired(documentId, &quot;id&quot;);</span>
<span class="nc" id="L358">        ValidationUtil.validateRequired(idList, &quot;order&quot;);</span>
        
        // Get the document
<span class="nc" id="L361">        AclDao aclDao = new AclDao();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (!aclDao.checkPermission(documentId, PermType.WRITE, getTargetIdList(null))) {</span>
<span class="nc" id="L363">            throw new NotFoundException();</span>
        }
        
        // Reorder files
<span class="nc" id="L367">        FileDao fileDao = new FileDao();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        for (File file : fileDao.getByDocumentId(principal.getId(), documentId)) {</span>
<span class="nc" id="L369">            int order = idList.lastIndexOf(file.getId());</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (order != -1) {</span>
<span class="nc" id="L371">                file.setOrder(order);</span>
            }
<span class="nc" id="L373">        }</span>

        // Raise a document updated event
<span class="nc" id="L376">        DocumentUpdatedAsyncEvent event = new DocumentUpdatedAsyncEvent();</span>
<span class="nc" id="L377">        event.setUserId(principal.getId());</span>
<span class="nc" id="L378">        event.setDocumentId(documentId);</span>
<span class="nc" id="L379">        ThreadLocalContext.get().addAsyncEvent(event);</span>
        
        // Always return OK
<span class="nc" id="L382">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L383">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="nc" id="L384">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Returns files linked to a document or not linked to any document.
     *
     * @api {get} /file/list Get files
     * @apiName GetFileList
     * @apiGroup File
     * @apiParam {String} id Document ID
     * @apiParam {String} share Share ID
     * @apiSuccess {Object[]} files List of files
     * @apiSuccess {String} files.id ID
     * @apiSuccess {String} files.processing True if the file is currently processing
     * @apiSuccess {String} files.name File name
     * @apiSuccess {String} files.version Zero-based version number
     * @apiSuccess {String} files.mimetype MIME type
     * @apiSuccess {String} files.document_id Document ID
     * @apiSuccess {String} files.create_date Create date (timestamp)
     * @apiSuccess {String} files.size File size (in bytes)
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) NotFound Document not found
     * @apiError (server) FileError Unable to get the size of a file
     * @apiPermission none
     * @apiVersion 1.5.0
     *
     * @param documentId Document ID
     * @param shareId Sharing ID
     * @return Response
     */
    @GET
    @Path(&quot;list&quot;)
    public Response list(
            @QueryParam(&quot;id&quot;) String documentId,
            @QueryParam(&quot;share&quot;) String shareId) {
<span class="nc" id="L419">        boolean authenticated = authenticate();</span>
        
        // Check document visibility
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (documentId != null) {</span>
<span class="nc" id="L423">            AclDao aclDao = new AclDao();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (!aclDao.checkPermission(documentId, PermType.READ, getTargetIdList(shareId))) {</span>
<span class="nc" id="L425">                throw new NotFoundException();</span>
            }
<span class="nc bnc" id="L427" title="All 2 branches missed.">        } else if (!authenticated) {</span>
<span class="nc" id="L428">            throw new ForbiddenClientException();</span>
        }

<span class="nc" id="L431">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L432">        JsonArrayBuilder files = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        for (File fileDb : fileDao.getByDocumentId(principal.getId(), documentId)) {</span>
<span class="nc" id="L434">            files.add(RestUtil.fileToJsonObjectBuilder(fileDb));</span>
<span class="nc" id="L435">        }</span>
<span class="nc" id="L436">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L437">                .add(&quot;files&quot;, files);</span>

<span class="nc" id="L439">        return Response.ok().entity(response.build()).build();</span>
    }

    /**
     * List all versions of a file.
     *
     * @api {get} /file/id/versions Get versions of a file
     * @apiName GetFileVersions
     * @apiGroup File
     * @apiParam {String} id File ID
     * @apiSuccess {Object[]} files List of files
     * @apiSuccess {String} files.id ID
     * @apiSuccess {String} files.name File name
     * @apiSuccess {String} files.version Zero-based version number
     * @apiSuccess {String} files.mimetype MIME type
     * @apiSuccess {String} files.create_date Create date (timestamp)
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) NotFound File not found
     * @apiPermission user
     * @apiVersion 1.5.0
     *
     * @param id File ID
     * @return Response
     */
    @GET
    @Path(&quot;{id: [a-z0-9\\-]+}/versions&quot;)
    public Response versions(@PathParam(&quot;id&quot;) String id) {
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L467">            throw new ForbiddenClientException();</span>
        }

        // Get versions
<span class="nc" id="L471">        File file = findFile(id, null);</span>
<span class="nc" id="L472">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L473">        List&lt;File&gt; fileList = Lists.newArrayList(file);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (file.getVersionId() != null) {</span>
<span class="nc" id="L475">            fileList = fileDao.getByVersionId(file.getVersionId());</span>
        }

<span class="nc" id="L478">        JsonArrayBuilder files = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        for (File fileDb : fileList) {</span>
<span class="nc" id="L480">            files.add(Json.createObjectBuilder()</span>
<span class="nc" id="L481">                    .add(&quot;id&quot;, fileDb.getId())</span>
<span class="nc" id="L482">                    .add(&quot;name&quot;, JsonUtil.nullable(fileDb.getName()))</span>
<span class="nc" id="L483">                    .add(&quot;version&quot;, fileDb.getVersion())</span>
<span class="nc" id="L484">                    .add(&quot;mimetype&quot;, fileDb.getMimeType())</span>
<span class="nc" id="L485">                    .add(&quot;create_date&quot;, fileDb.getCreateDate().getTime()));</span>
<span class="nc" id="L486">        }</span>

<span class="nc" id="L488">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L489">                .add(&quot;files&quot;, files);</span>
<span class="nc" id="L490">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Deletes a file.
     *
     * @api {delete} /file/:id Delete a file
     * @apiName DeleteFile
     * @apiGroup File
     * @apiParam {String} id File ID
     * @apiParam {String} share Share ID
     * @apiSuccess {String} status Status OK
     * @apiError (client) ForbiddenError Access denied
     * @apiError (client) NotFound File or document not found
     * @apiPermission user
     * @apiVersion 1.5.0
     *
     * @param id File ID
     * @return Response
     */
    @DELETE
    @Path(&quot;{id: [a-z0-9\\-]+}&quot;)
    public Response delete(
            @PathParam(&quot;id&quot;) String id) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (!authenticate()) {</span>
<span class="nc" id="L515">            throw new ForbiddenClientException();</span>
        }

        // Get the file
<span class="nc" id="L519">        File file = findFile(id, null);</span>

        // Delete the file
<span class="nc" id="L522">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L523">        fileDao.delete(file.getId(), principal.getId());</span>
        
        // Update the user quota
<span class="nc" id="L526">        UserDao userDao = new UserDao();</span>
<span class="nc" id="L527">        User user = userDao.getById(principal.getId());</span>
<span class="nc" id="L528">        java.nio.file.Path storedFile = DirectoryUtil.getStorageDirectory().resolve(id);</span>
        try {
<span class="nc" id="L530">            user.setStorageCurrent(user.getStorageCurrent() - Files.size(storedFile));</span>
<span class="nc" id="L531">            userDao.updateQuota(user);</span>
<span class="nc" id="L532">        } catch (IOException e) {</span>
            // The file doesn't exists on disk, which is weird, but not fatal
<span class="nc" id="L534">        }</span>
        
        // Raise a new file deleted event
<span class="nc" id="L537">        FileDeletedAsyncEvent fileDeletedAsyncEvent = new FileDeletedAsyncEvent();</span>
<span class="nc" id="L538">        fileDeletedAsyncEvent.setUserId(principal.getId());</span>
<span class="nc" id="L539">        fileDeletedAsyncEvent.setFileId(file.getId());</span>
<span class="nc" id="L540">        ThreadLocalContext.get().addAsyncEvent(fileDeletedAsyncEvent);</span>
        
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (file.getDocumentId() != null) {</span>
            // Raise a new document updated
<span class="nc" id="L544">            DocumentUpdatedAsyncEvent documentUpdatedAsyncEvent = new DocumentUpdatedAsyncEvent();</span>
<span class="nc" id="L545">            documentUpdatedAsyncEvent.setUserId(principal.getId());</span>
<span class="nc" id="L546">            documentUpdatedAsyncEvent.setDocumentId(file.getDocumentId());</span>
<span class="nc" id="L547">            ThreadLocalContext.get().addAsyncEvent(documentUpdatedAsyncEvent);</span>
        }
        
        // Always return OK
<span class="nc" id="L551">        JsonObjectBuilder response = Json.createObjectBuilder()</span>
<span class="nc" id="L552">                .add(&quot;status&quot;, &quot;ok&quot;);</span>
<span class="nc" id="L553">        return Response.ok().entity(response.build()).build();</span>
    }
    
    /**
     * Returns a file.
     *
     * @api {get} /file/:id/data Get a file data
     * @apiName GetFile
     * @apiGroup File
     * @apiParam {String} id File ID
     * @apiParam {String} share Share ID
     * @apiParam {String=&quot;web&quot;,&quot;thumb&quot;,&quot;content&quot;} [size] Size variation
     * @apiSuccess {Object} file The file data is the whole response
     * @apiError (client) SizeError Size must be web or thumb
     * @apiError (client) ForbiddenError Access denied or document not visible
     * @apiError (client) NotFound File not found
     * @apiError (server) ServiceUnavailable Error reading the file
     * @apiPermission none
     * @apiVersion 1.5.0
     *
     * @param fileId File ID
     * @return Response
     */
    @GET
    @Path(&quot;{id: [a-z0-9\\-]+}/data&quot;)
    @Produces(MediaType.APPLICATION_OCTET_STREAM)
    public Response data(
            @PathParam(&quot;id&quot;) final String fileId,
            @QueryParam(&quot;share&quot;) String shareId,
            @QueryParam(&quot;size&quot;) String size) {
<span class="nc" id="L583">        authenticate();</span>
        
<span class="nc bnc" id="L585" title="All 4 branches missed.">        if (size != null &amp;&amp; !Lists.newArrayList(&quot;web&quot;, &quot;thumb&quot;, &quot;content&quot;).contains(size)) {</span>
<span class="nc" id="L586">            throw new ClientException(&quot;SizeError&quot;, &quot;Size must be web, thumb or content&quot;);</span>
        }

        // Get the file
<span class="nc" id="L590">        File file = findFile(fileId, shareId);</span>

        // Get the stored file
<span class="nc" id="L593">        UserDao userDao = new UserDao();</span>
        java.nio.file.Path storedFile;
        String mimeType;
        boolean decrypt;
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (size != null) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (size.equals(&quot;content&quot;)) {</span>
<span class="nc" id="L599">                return Response.ok(Strings.nullToEmpty(file.getContent()))</span>
<span class="nc" id="L600">                        .header(HttpHeaders.CONTENT_TYPE, &quot;text/plain; charset=utf-8&quot;)</span>
<span class="nc" id="L601">                        .build();</span>
            }

<span class="nc" id="L604">            storedFile = DirectoryUtil.getStorageDirectory().resolve(fileId + &quot;_&quot; + size);</span>
<span class="nc" id="L605">            mimeType = MimeType.IMAGE_JPEG; // Thumbnails are JPEG</span>
<span class="nc" id="L606">            decrypt = true; // Thumbnails are encrypted</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (!Files.exists(storedFile)) {</span>
                try {
<span class="nc" id="L609">                    storedFile = Paths.get(getClass().getResource(&quot;/image/file-&quot; + size + &quot;.png&quot;).toURI());</span>
<span class="nc" id="L610">                } catch (URISyntaxException e) {</span>
                    // Ignore
<span class="nc" id="L612">                }</span>
<span class="nc" id="L613">                mimeType = MimeType.IMAGE_PNG;</span>
<span class="nc" id="L614">                decrypt = false;</span>
            }
        } else {
<span class="nc" id="L617">            storedFile = DirectoryUtil.getStorageDirectory().resolve(fileId);</span>
<span class="nc" id="L618">            mimeType = file.getMimeType();</span>
<span class="nc" id="L619">            decrypt = true; // Original files are encrypted</span>
        }
        
        // Stream the output and decrypt it if necessary
        StreamingOutput stream;
        
        // A file is always encrypted by the creator of it
<span class="nc" id="L626">        User user = userDao.getById(file.getUserId());</span>
        
        // Write the decrypted file to the output
        try {
<span class="nc" id="L630">            InputStream fileInputStream = Files.newInputStream(storedFile);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            final InputStream responseInputStream = decrypt ?</span>
<span class="nc" id="L632">                    EncryptionUtil.decryptInputStream(fileInputStream, user.getPrivateKey()) : fileInputStream;</span>
                    
<span class="nc" id="L634">            stream = outputStream -&gt; {</span>
                try {
<span class="nc" id="L636">                    ByteStreams.copy(responseInputStream, outputStream);</span>
                } finally {
                    try {
<span class="nc" id="L639">                        responseInputStream.close();</span>
<span class="nc" id="L640">                        outputStream.close();</span>
<span class="nc" id="L641">                    } catch (IOException e) {</span>
                        // Ignore
<span class="nc" id="L643">                    }</span>
                }
<span class="nc" id="L645">            };</span>
<span class="nc" id="L646">        } catch (Exception e) {</span>
<span class="nc" id="L647">            return Response.status(Status.SERVICE_UNAVAILABLE).build();</span>
<span class="nc" id="L648">        }</span>

<span class="nc" id="L650">        Response.ResponseBuilder builder = Response.ok(stream)</span>
<span class="nc" id="L651">                .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + file.getFullName(&quot;data&quot;) + &quot;\&quot;&quot;)</span>
<span class="nc" id="L652">                .header(HttpHeaders.CONTENT_TYPE, mimeType);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (decrypt) {</span>
            // Cache real files
<span class="nc" id="L655">            builder.header(HttpHeaders.CACHE_CONTROL, &quot;private&quot;)</span>
<span class="nc" id="L656">                    .header(HttpHeaders.EXPIRES, HttpUtil.buildExpiresHeader(3_600_000L * 24L * 365L));</span>
        } else {
            // Do not cache the temporary thumbnail
<span class="nc" id="L659">            builder.header(HttpHeaders.CACHE_CONTROL, &quot;no-store, must-revalidate&quot;)</span>
<span class="nc" id="L660">                    .header(HttpHeaders.EXPIRES, &quot;0&quot;);</span>
        }
<span class="nc" id="L662">        return builder.build();</span>
    }

    /**
     * Returns all files from a document, zipped.
     *
     * @api {get} /file/zip Returns all files from a document, zipped.
     * @apiName GetFileZip
     * @apiGroup File
     * @apiParam {String} id Document ID
     * @apiParam {String} share Share ID
     * @apiSuccess {Object} file The ZIP file is the whole response
     * @apiError (client) NotFoundException Document not found
     * @apiError (server) InternalServerError Error creating the ZIP file
     * @apiPermission none
     * @apiVersion 1.5.0
     *
     * @param documentId Document ID
     * @param shareId Share ID
     * @return Response
     */
    @GET
    @Path(&quot;zip&quot;)
    @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.TEXT_PLAIN})
    public Response zip(
            @QueryParam(&quot;id&quot;) String documentId,
            @QueryParam(&quot;share&quot;) String shareId) {
<span class="nc" id="L689">        authenticate();</span>
        
        // Get the document
<span class="nc" id="L692">        DocumentDao documentDao = new DocumentDao();</span>
<span class="nc" id="L693">        DocumentDto documentDto = documentDao.getDocument(documentId, PermType.READ, getTargetIdList(shareId));</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (documentDto == null) {</span>
<span class="nc" id="L695">            throw new NotFoundException();</span>
        }

        // Get files associated with this document
<span class="nc" id="L699">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L700">        final List&lt;File&gt; fileList = fileDao.getByDocumentId(principal.getId(), documentId);</span>
<span class="nc" id="L701">        String zipFileName = documentDto.getTitle().replaceAll(&quot;\\W+&quot;, &quot;_&quot;);</span>
<span class="nc" id="L702">        return sendZippedFiles(zipFileName, fileList);</span>
    }

    /**
     * Returns a list of files, zipped
     *
     * @api {post} /file/zip Returns a list of files, zipped
     * @apiName GetFilesZip
     * @apiGroup File
     * @apiParam {String[]} files IDs
     * @apiSuccess {Object} file The ZIP file is the whole response
     * @apiError (client) NotFoundException Files not found
     * @apiError (server) InternalServerError Error creating the ZIP file
     * @apiPermission none
     * @apiVersion 1.11.0
     *
     * @param filesIdsList Files IDs
     * @return Response
     */
    @POST
    @Path(&quot;zip&quot;)
    @Produces({MediaType.APPLICATION_OCTET_STREAM, MediaType.TEXT_PLAIN})
    public Response zip(
            @FormParam(&quot;files&quot;) List&lt;String&gt; filesIdsList) {
<span class="nc" id="L726">        authenticate();</span>
<span class="nc" id="L727">        List&lt;File&gt; fileList = findFiles(filesIdsList);</span>
<span class="nc" id="L728">        return sendZippedFiles(&quot;files&quot;, fileList);</span>
    }

    /**
     * Sent the content of a list of files.
     */
    private Response sendZippedFiles(String zipFileName, List&lt;File&gt; fileList) {
<span class="nc" id="L735">        final UserDao userDao = new UserDao();</span>

        // Create the ZIP stream
<span class="nc" id="L738">        StreamingOutput stream = outputStream -&gt; {</span>
<span class="nc" id="L739">            try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {</span>
                // Add each file to the ZIP stream
<span class="nc" id="L741">                int index = 0;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                for (File file : fileList) {</span>
<span class="nc" id="L743">                    java.nio.file.Path storedfile = DirectoryUtil.getStorageDirectory().resolve(file.getId());</span>
<span class="nc" id="L744">                    InputStream fileInputStream = Files.newInputStream(storedfile);</span>

                    // Add the decrypted file to the ZIP stream
                    // Files are encrypted by the creator of them
<span class="nc" id="L748">                    User user = userDao.getById(file.getUserId());</span>
<span class="nc" id="L749">                    try (InputStream decryptedStream = EncryptionUtil.decryptInputStream(fileInputStream, user.getPrivateKey())) {</span>
<span class="nc" id="L750">                        ZipEntry zipEntry = new ZipEntry(index + &quot;-&quot; + file.getFullName(Integer.toString(index)));</span>
<span class="nc" id="L751">                        zipOutputStream.putNextEntry(zipEntry);</span>
<span class="nc" id="L752">                        ByteStreams.copy(decryptedStream, zipOutputStream);</span>
<span class="nc" id="L753">                        zipOutputStream.closeEntry();</span>
<span class="nc" id="L754">                    } catch (Exception e) {</span>
<span class="nc" id="L755">                        throw new WebApplicationException(e);</span>
<span class="nc" id="L756">                    }</span>
<span class="nc" id="L757">                    index++;</span>
<span class="nc" id="L758">                }</span>
            }
<span class="nc" id="L760">            outputStream.close();</span>
<span class="nc" id="L761">        };</span>
        
        // Write to the output
<span class="nc" id="L764">        return Response.ok(stream)</span>
<span class="nc" id="L765">                .header(&quot;Content-Type&quot;, &quot;application/zip&quot;)</span>
<span class="nc" id="L766">                .header(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + zipFileName + &quot;.zip\&quot;&quot;)</span>
<span class="nc" id="L767">                .build();</span>
    }

    /**
     * Find a file with access rights checking.
     *
     * @param fileId File ID
     * @param shareId Share ID
     * @return File
     */
    private File findFile(String fileId, String shareId) {
<span class="nc" id="L778">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L779">        File file = fileDao.getFile(fileId);</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (file == null) {</span>
<span class="nc" id="L781">            throw new NotFoundException();</span>
        }
<span class="nc" id="L783">        checkFileAccessible(shareId, file);</span>
<span class="nc" id="L784">        return file;</span>
    }


    /**
     * Find a list of files with access rights checking.
     *
     * @param filesIds Files IDs
     * @return List&lt;File&gt;
     */
    private List&lt;File&gt; findFiles(List&lt;String&gt; filesIds) {
<span class="nc" id="L795">        FileDao fileDao = new FileDao();</span>
<span class="nc" id="L796">        List&lt;File&gt; files = fileDao.getFiles(filesIds);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L798">            checkFileAccessible(null, file);</span>
<span class="nc" id="L799">        }</span>
<span class="nc" id="L800">        return files;</span>
    }

    /**
     * Check if a file is accessible to the current user
     * @param shareId Share ID
     * @param file
     */
    private void checkFileAccessible(String shareId, File file) {
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (file.getDocumentId() == null) {</span>
            // It's an orphan file
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (!file.getUserId().equals(principal.getId())) {</span>
                // But not ours
<span class="nc" id="L813">                throw new ForbiddenClientException();</span>
            }
        } else {
            // Check document accessibility
<span class="nc" id="L817">            AclDao aclDao = new AclDao();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if (!aclDao.checkPermission(file.getDocumentId(), PermType.READ, getTargetIdList(shareId))) {</span>
<span class="nc" id="L819">                throw new ForbiddenClientException();</span>
            }
        }
<span class="nc" id="L822">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>